//Recursion (TLE)

class Solution {
    private:
    bool helper(string& s, string& p, int i, int j){
        //both gets exhausted 
        if(i<0  && j<0) return true;

        //pattern is empty but string is not 
        if(j<0 && i>=0) return false;

        //string is empty but pattern is not
        if(i<0 && j>=0){
            if(p[j]=='*') return helper(s,p,i,j-1);
        return false;
        }
    
        //chars are same
        if(s[i]==p[j] || p[j]=='?')
            return helper(s,p,i-1,j-1);

        //*
        if(p[j]=='*')
            return helper(s,p,i,j-1)||helper(s,p,i-1,j);
    
    return false;
    }
public:
    bool isMatch(string s, string p) {
        return helper(s,p,s.size()-1,p.size()-1);
    }
};


//Memoization 

class Solution {
    private:
    bool helper(string& s, string& p, int i, int j, vector<vector<int>>& dp){
        //base conditions 
        //both gets exhausted 
        if(i<0  && j<0) return true;
        //pattern is empty but string is not 
        if(j<0 && i>=0) return false;
        //string is empty but pattern is not
        if(i<0 && j>=0){
            if(p[j]=='*') return helper(s,p,i,j-1,dp);
        return false;
        }
        //check
        if(dp[i][j]!=-1) return dp[i][j];
        //chars are same
        if(s[i]==p[j] || p[j]=='?')
            return dp[i][j] = helper(s,p,i-1,j-1,dp);

        //*
        if(p[j]=='*')
            return dp[i][j] = helper(s,p,i,j-1,dp)||helper(s,p,i-1,j,dp);
    
    return dp[i][j] = false;
    }
public:
    bool isMatch(string s, string p) {
        vector<vector<int>> dp(s.size(), vector<int> (p.size(), -1));
        return helper(s,p,s.size()-1,p.size()-1,dp);
    }
};
